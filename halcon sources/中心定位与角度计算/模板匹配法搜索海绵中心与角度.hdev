<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="17.12">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<l>dev_update_window ('off')</l>
<c></c>
<l>pi := 3.1415926</l>
<c></c>
<l>read_image (Image, 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000002.bmp')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_open_window (0, 0, Width, Height, 'black', WindowHandle)</l>
<l>dev_display (Image)</l>
<l>*dev_set_draw ('margin')</l>
<c>*step:创建模板</c>
<l>rotate_image (Image, ImageRotate, -4.6454, 'constant')</l>
<l>gen_rectangle1 (ROI_0, 217, 332, 456, 509)</l>
<l>reduce_domain (ImageRotate, ROI_0, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, 35, 87)</l>
<l>closing_circle (Regions, RegionClosing, 6)</l>
<l>reduce_domain (ImageReduced, RegionClosing, ImageReduced1)</l>
<l>dev_clear_window ()</l>
<l>dev_display (ImageReduced1)</l>
<c>*方法一：基于像素灰度值的模板匹配</c>
<l>create_ncc_model (ImageReduced1, 'auto', 0, rad(360), 'auto', 'use_polarity', ModelID1)</l>
<c>*方法二：基于等比缩放轮廓形状的模板匹配</c>
<l>create_scaled_shape_model (ImageReduced1, 'auto', 0, rad(360), 'auto', 0.5, 2, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID2)</l>
<l>stop()</l>
<c></c>
<c>*</c>
<c>*方法三：基于异向缩放轮廓形状的模板匹配</c>
<l>boundary (RegionClosing, RegionBorder, 'inner')</l>
<l>gen_contour_region_xld (RegionBorder, Contours1, 'center')</l>
<l>smooth_contours_xld (Contours1, SmoothedContours, 11)</l>
<l>dev_clear_window ()</l>
<l>dev_display (SmoothedContours)</l>
<l>create_aniso_shape_model_xld (SmoothedContours, 'auto', 0, rad(360), 'auto', 0.5, 2, 'auto', 1, 1, 'auto', 'auto', 'ignore_local_polarity', 5, ModelID)</l>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<l>stop()</l>
<c>*</c>
<c>*step2:读图寻找模板</c>
<c>* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l>ImageFiles := []</l>
<l>ImageFiles[0] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000002.bmp'</l>
<l>ImageFiles[1] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000003.bmp'</l>
<l>ImageFiles[2] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000004.bmp'</l>
<l>ImageFiles[3] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000005.bmp'</l>
<l>ImageFiles[4] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000006.bmp'</l>
<l>ImageFiles[5] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000007.bmp'</l>
<l>for Index := 0 to |ImageFiles| - 1 by 1</l>
<l>    count_seconds (Second1)</l>
<l>    read_image (Image, ImageFiles[Index])</l>
<l>    dev_display (Image)</l>
<c>    *方法一：基于像素灰度值的模板匹配</c>
<l>    count_seconds (Second2)</l>
<l>    find_ncc_model (Image, ModelID1, 0, rad(360), 0.5, 1, 0.5, 'true', 0, Row1, Column1, Angle1, Score1)</l>
<l>    ANGLE1 := deg(Angle1)</l>
<l>    gen_cross_contour_xld (Cross1, Row1, Column1, 20, 0)</l>
<l>    gen_arrow_contour_xld (Arrow1, Row1, Column1, Row1 - cos(Angle1 - pi/2)*60 , Column1 - sin(Angle1 - pi/2)*60 , 5, 5)</l>
<l>    dev_set_line_width(3)</l>
<l>    dev_set_color ('yellow')</l>
<l>    dev_display (Cross1)</l>
<l>    dev_set_color ('yellow')</l>
<l>    dev_display (Arrow1)</l>
<l>    dev_set_color ('yellow')</l>
<c>    </c>
<l>    count_seconds (Second3)</l>
<l>    Time2 := round( 1000*(Second3 - Second2 ) )</l>
<c>    </c>
<l>    set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>    disp_message (WindowHandle, '基于像素灰度值模板匹配(黄色十字和箭头):', 'window', 110, 20, 'red', 'true')    </l>
<l>    disp_message (WindowHandle, 'X:'+Row1, 'window', 140, 20, 'black', 'true')</l>
<l>    disp_message (WindowHandle, 'Y:'+Column1, 'window', 160, 20, 'black', 'true')</l>
<l>    disp_message (WindowHandle, 'ANGLE:' + ANGLE1$'3.2f' + '°', 'window', 180, 20, 'black', 'true')</l>
<l>    disp_message (WindowHandle, '基于像素灰度值模板Time:' + Time2$'.2f' + 'ms', 'window', 65, 500, 'green', 'false')</l>
<c>    </c>
<c>    *方法二：基于轮廓形状的模板匹配</c>
<l>    count_seconds (Second4)</l>
<l>    find_aniso_shape_model (Image, ModelID, 0, rad(360), 0.5, 2, 1, 1, 0.5, 1, 0.5,  'interpolation', 0, 0.9, Row, Column, Angle, ScaleR, ScaleC, Score)</l>
<l>    *find_shape_model (Image, ModelID, 0, rad(360), 0.5, 1, 0.8, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>    ANGLE := deg(Angle)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_scale (HomMat2DIdentity, ScaleR, ScaleC, 0, 0, HomMat2DScale)</l>
<l>    hom_mat2d_rotate (HomMat2DScale, Angle, 0, 0, HomMat2DRotate)</l>
<l>    hom_mat2d_translate (HomMat2DRotate, Row, Column, HomMat2DTranslate)</l>
<l>    affine_trans_contour_xld (ModelContours, ContoursAffineTrans, HomMat2DTranslate)</l>
<c>   </c>
<l>    gen_cross_contour_xld (Cross, Row, Column, 20, 0)</l>
<l>    gen_arrow_contour_xld (Arrow, Row, Column, Row - cos(Angle - pi/2)*60 , Column - sin(Angle - pi/2)*60 , 5, 5)</l>
<l>    dev_set_line_width(3)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (ContoursAffineTrans)   </l>
<l>    dev_display (Cross)</l>
<l>    dev_set_color ('red')</l>
<l>    dev_display (Arrow)</l>
<l>    dev_set_color ('yellow')</l>
<c>    </c>
<l>    count_seconds (Second5)</l>
<l>    Time1 := round(1000*(Second5 - Second4))</l>
<c>    </c>
<l>    set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>    disp_message (WindowHandle, '基于异向缩放轮廓模板匹配(绿色十字和红色箭头):', 'window', 10, 20, 'red', 'true')    </l>
<l>    disp_message (WindowHandle, 'X:'+Row, 'window', 40, 20, 'black', 'true')</l>
<l>    disp_message (WindowHandle, 'Y:'+Column, 'window', 60, 20, 'black', 'true')</l>
<l>    disp_message (WindowHandle, 'ANGLE:' + ANGLE$'3.2f' + '°', 'window', 80, 20, 'black', 'true')</l>
<l>    disp_message (WindowHandle, '基于异向缩放轮廓模板Time:' + Time1$'.2f' + 'ms', 'window', 45, 500, 'green', 'false')</l>
<c>    </c>
<l>    dump_window_image (Image1, WindowHandle)</l>
<l>    dev_display (Image1)</l>
<l>    stop()</l>
<l>endfor</l>
<c></c>
<c></c>
<l>clear_shape_model (ModelID)</l>
<l>clear_ncc_model (ModelID1)</l>
<l>clear_shape_model (ModelID2)</l>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
