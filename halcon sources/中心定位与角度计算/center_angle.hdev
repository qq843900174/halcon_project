<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="17.12">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<l>dev_update_window ('off')</l>
<c></c>
<l>*read_image (Image, 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000007.bmp')</l>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2]" as_ord="1">ImageFiles := []</l>
<l>ImageFiles[0] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000002.bmp'</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,3]" as_ord="2">ImageFiles[1] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000003.bmp'</l>
<l>ImageFiles[2] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000004.bmp'</l>
<l>ImageFiles[3] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000005.bmp'</l>
<l>ImageFiles[4] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000006.bmp'</l>
<l>ImageFiles[5] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000007.bmp'</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,2]" as_ord="1">for Index := 0 to |ImageFiles| - 1 by 1</l>
<l>    count_seconds (Second1)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,3]" as_ord="1">    read_image (Image, ImageFiles[Index])</l>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,4]" as_ord="1">    * Image Acquisition 01: Do something</c>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_open_window (0, 0, Width, Height, 'black', WindowHandle)</l>
<l>dev_display (Image)</l>
<l>dev_set_draw ('margin')</l>
<l>threshold (Image, Regions, 0, 90)</l>
<l>connection (Regions, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 20000, 40000)</l>
<l>closing_circle (SelectedRegions, RegionClosing, 5)</l>
<l>opening_circle (RegionClosing, RegionOpening, 5)</l>
<c></c>
<c>*方法一:区域最小外接矩形</c>
<l>* smallest_rectangle2 (RegionOpening, Row, Column, Phi, Length1, Length2)</l>
<l>* gen_rectangle2 (Rectangle, Row, Column, Phi, Length1, Length2)</l>
<l>* gen_cross_contour_xld (Cross, Row, Column, 10, Phi)</l>
<l>* dev_display (Rectangle)</l>
<l>* dev_set_color ('yellow')</l>
<l>* dev_display (Cross)</l>
<l>* disp_message (WindowHandle, 'center_X:'+Row, 'window', 20, 20, 'green', 'false')</l>
<l>* disp_message (WindowHandle, 'center_Y:'+Column, 'window', 40, 20, 'green', 'false')</l>
<l>* disp_message (WindowHandle, 'center_Angle:'+Phi, 'window', 60, 20, 'green', 'false')</l>
<c></c>
<c></c>
<c>*方法二：拟合直线，判断直线角度</c>
<l>boundary (RegionOpening, RegionBorder, 'inner')</l>
<l>gen_contour_region_xld (RegionBorder, Contours, 'border')</l>
<l>dev_set_colored (12)</l>
<l>segment_contours_xld (Contours, ContoursSplit, 'lines', 5, 4, 2)</l>
<l> regress_contours_xld (ContoursSplit, RegressContours, 'no', 1)</l>
<l> union_collinear_contours_xld (RegressContours, UnionContours, 10, 1, 2, 0.1, 'attr_keep')</l>
<l>*sort_contours_xld (UnionContours, SortedContours, 'upper_left', 'true', 'row')</l>
<l> sort_contours_xld (UnionContours, SortedContours, 'upper_left', 'true', 'column')</l>
<l>* dev_display (SortedContours)</l>
<c></c>
<l>* fit_line_contour_xld (SortedContours, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist) </l>
<c>*长边</c>
<l>select_contours_xld (UnionContours, SelectedContours_L1, 'contour_length', 140, 300, -0.5, 0.5)</l>
<c>*短边</c>
<l>select_contours_xld (UnionContours, SelectedContours_L2, 'contour_length', 50, 140, -0.5, 0.5)</l>
<c></c>
<c></c>
<l>dev_display (SelectedContours_L1)</l>
<l>dev_display (SelectedContours_L2)</l>
<c>*长边角度参数</c>
<l>Phi_L1 := []</l>
<l>l1_count := 0</l>
<c></c>
<c>*短边角度参数</c>
<l>Phi_L2 := []</l>
<l>l2_count := 0</l>
<c></c>
<l>count_obj (SelectedContours_L1, Number_L1)</l>
<l>for i:= 1 to Number_L1 by 1</l>
<l>    select_obj (SelectedContours_L1, ObjectSelected_L1, i)</l>
<l>    fit_line_contour_xld (ObjectSelected_L1, 'tukey', -1, 0, 5, 2, RowBegin_L1, ColBegin_L1, RowEnd_L1, ColEnd_L1, Nr_L1, Nc_L1, Dist_L1)</l>
<l>    line_orientation (RowBegin_L1, ColBegin_L1, RowEnd_L1, ColEnd_L1, Phi_1)</l>
<l>    Phi_L1[l1_count] := Phi_1</l>
<l>    l1_count := l1_count + 1 </l>
<l>endfor</l>
<c></c>
<l>count_obj (SelectedContours_L2, Number_L2)</l>
<l>for i:= 1 to Number_L2 by 1</l>
<l>    select_obj (SelectedContours_L2, ObjectSelected_L2, i)</l>
<l>    fit_line_contour_xld (ObjectSelected_L2, 'tukey', -1, 0, 5, 2, RowBegin_L2, ColBegin_L2, RowEnd_L2, ColEnd_L2, Nr_L2, Nc_L2, Dist_L2)</l>
<l>    line_orientation (RowBegin_L2, ColBegin_L2, RowEnd_L2, ColEnd_L2, Phi_2)</l>
<l>    Phi_L2[l2_count] := Phi_2</l>
<l>    l2_count := l2_count + 1 </l>
<l>endfor</l>
<c></c>
<l>tuple_mean (Phi_L1, Phi_L1_mean)</l>
<l>tuple_mean (Phi_L2, Phi_L2_mean)</l>
<c></c>
<l>gen_region_contour_xld (SelectedContours_L1, Region_L1, 'margin')</l>
<l>gen_region_contour_xld (SelectedContours_L2, Region_L2, 'margin')</l>
<l>union2 (Region_L1, Region_L2, RegionUnion)</l>
<l>union1 (RegionUnion, RegionUnion1)</l>
<l>smallest_rectangle2 (RegionUnion1, Row1, Column1, Phi1, Length11, Length21)</l>
<l>gen_rectangle2 (Rectangle1, Row1, Column1, Phi1, Length11, Length21)</l>
<c></c>
<c></c>
<l>gen_cross_contour_xld (Cross1, Row1, Column1, 20, 0)</l>
<l>gen_arrow_contour_xld (Arrow, Row1, Column1, Row1 - cos(Phi_L1_mean)*60 , Column1 - sin(Phi_L1_mean)*60 , 5, 5)</l>
<c></c>
<l>Phi_L1_mean_deg := deg(Phi_L1_mean)</l>
<c></c>
<l>dev_set_line_width(3)</l>
<l>dev_display (Image)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (Rectangle1)</l>
<l>dev_display (Cross1)</l>
<l>dev_set_color ('red')</l>
<l>dev_display (Arrow)</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (SelectedContours_L1)</l>
<l>dev_display (SelectedContours_L2)</l>
<l>count_seconds (Second2)</l>
<l>Time := round(1000*(Second2 - Second1))</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>disp_message (WindowHandle, '边缘轮廓拟合直线算法:', 'window', 10, 20, 'red', 'true')</l>
<l>disp_message (WindowHandle, 'X:'+Row1, 'window', 40, 20, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Y:'+Column1, 'window', 60, 20, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'ANGLE:' + (deg(Phi_L1_mean)+90)$'3.2f' + '°', 'window', 80, 20, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Time:' + Time$'.2f' + 'ms', 'window', 45, 650, 'green', 'false')</l>
<c></c>
<l>stop()</l>
<l>endfor</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
