<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="17.12">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<l>dev_update_window ('off')</l>
<c></c>
<l>pi := 3.1415926</l>
<c></c>
<l>read_image (Image, 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000002.bmp')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>dev_open_window (0, 0, Width, Height, 'black', WindowHandle)</l>
<l>dev_display (Image)</l>
<l>*dev_set_draw ('margin')</l>
<c>*一、创建匹配模板和测量模型。</c>
<c>*1.创建匹配模板</c>
<l>rotate_image (Image, ImageRotate, -4.6454, 'constant')</l>
<l>gen_rectangle1 (ROI_0, 217, 332, 456, 509)</l>
<l>reduce_domain (ImageRotate, ROI_0, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, 35, 87)</l>
<l>closing_circle (Regions, RegionClosing, 6)</l>
<l>reduce_domain (ImageReduced, RegionClosing, ImageReduced1)</l>
<l>dev_clear_window ()</l>
<l>dev_display (ImageReduced1)</l>
<c>*基于异向缩放轮廓形状的模板匹配</c>
<l>boundary (RegionClosing, RegionBorder, 'inner')</l>
<l>gen_contour_region_xld (RegionBorder, Contours1, 'center')</l>
<l>smooth_contours_xld (Contours1, SmoothedContours, 11)</l>
<l>dev_clear_window ()</l>
<l>dev_display (SmoothedContours)</l>
<l>create_aniso_shape_model_xld (SmoothedContours, 'auto', 0, rad(360), 'auto', 0.5, 2, 'auto',\
                              1, 1, 'auto', 'auto', 'ignore_local_polarity', 5, ModelID)</l>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<l>stop()</l>
<c></c>
<c>*2.创建测量模型</c>
<l>dev_clear_window ()</l>
<l>dev_display (Image)</l>
<l>gen_rectangle1 (ROI_1, 213, 316, 448, 512)</l>
<l>reduce_domain (Image, ROI_1, ImageReduced2)</l>
<l>threshold (ImageReduced2, Regions1, 35, 87)</l>
<l>closing_circle (Regions1, RegionClosing1, 6)</l>
<c></c>
<l>create_metrology_model (MetrologyHandle)</l>
<l>set_metrology_model_image_size (MetrologyHandle, Width, Height)</l>
<c></c>
<l>smallest_rectangle2 (RegionClosing1, Row1, Column1, Phi, Length1, Length2)</l>
<l>gen_rectangle2 (Rectangle, Row1, Column1, Phi, Length1, Length2)</l>
<l>dilation_circle (Rectangle, RegionDilation, 5)</l>
<l>reduce_domain (Image, RegionDilation, ImageReduced3)</l>
<c></c>
<l>add_metrology_object_rectangle2_measure (MetrologyHandle, Row1, Column1, Phi, Length1, Length2, \
                                         20, 5, 2, 20, ['measure_transition'], ['positive'], Index1)</l>
<c></c>
<c>*尝试把孔洞给填充</c>
<l>* gray_dilation_rect (ImageReduced3, ImageMax, 6, 6)</l>
<l>* gray_erosion_rect (ImageMax, ImageMin, 6, 6)</l>
<l>*gray_closing_rect (ImageReduced3, ImageClosing, 6, 6)</l>
<l>* gray_closing_shape (ImageReduced3, ImageClosing, 6, 6, 'octagon')</l>
<l>* gauss_filter (ImageReduced3, ImageGauss, 9)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (ImageClosing)</l>
<l>* dev_display (ImageMin)</l>
<l>* dev_display (ImageGauss)</l>
<l>* stop()</l>
<c></c>
<l>apply_metrology_model (ImageReduced3, MetrologyHandle)</l>
<l>get_metrology_object_result (MetrologyHandle, 'all', 'all', 'result_type', \
                             'all_param', Parameter)</l>
<l>get_metrology_object_result_contour (Contour, MetrologyHandle, 'all', 'all', 1.5)</l>
<l>dev_display (Contour)</l>
<l>dev_set_color ('green')</l>
<l>get_metrology_object_measures (Contours, MetrologyHandle, 'all', 'all', Row2, Column2)</l>
<l>dev_display (Contours)</l>
<l>dev_set_color ('yellow')</l>
<l>gen_cross_contour_xld (Cross, Row2, Column2, 4, 0.785398)</l>
<l>dev_display (Cross)</l>
<c></c>
<l>ANGLE := deg(Parameter[2])</l>
<l>disp_message (WindowHandle, 'X:'+Parameter[0], 'window', 40, 20, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Y:'+Parameter[1], 'window', 60, 20, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'ANGLE:' + ANGLE$'3.2f' + '°', 'window', 80, 20, 'black', 'true')</l>
<l>dump_window_image (Image2, WindowHandle)</l>
<l>stop()</l>
<c></c>
<c>*二、读图寻找模板并进行精密测量。</c>
<c>* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l>ImageFiles := []</l>
<l>ImageFiles[0] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000002.bmp'</l>
<l>ImageFiles[1] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000003.bmp'</l>
<l>ImageFiles[2] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000004.bmp'</l>
<l>ImageFiles[3] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000005.bmp'</l>
<l>ImageFiles[4] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000006.bmp'</l>
<l>ImageFiles[5] := 'C:/Users/acer/Desktop/halcon_project/images/center_angle/0_000007.bmp'</l>
<l>for Index := 0 to |ImageFiles| - 1 by 1</l>
<c>    *1.读图。</c>
<l>    count_seconds (Second1)</l>
<l>    read_image (Image, ImageFiles[Index])</l>
<l>    dev_display (Image)</l>
<c>    </c>
<c>    *2.模板匹配，寻找待测物初始中心和形状。</c>
<l>    find_aniso_shape_model (Image, ModelID, 0, rad(360), 0.5, 2, 0.8, 1.2, 0.5, 1, 0.5,  'interpolation', 0, 0.9, Row, Column, Angle, ScaleR, ScaleC, Score)</l>
<l>    *find_shape_model (Image, ModelID, 0, rad(360), 0.5, 1, 0.8, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>*     ANGLE := deg(Angle)</l>
<l>*     hom_mat2d_identity (HomMat2DIdentity)</l>
<l>*     hom_mat2d_scale (HomMat2DIdentity, ScaleR, ScaleC, 0, 0, HomMat2DScale)</l>
<l>*     hom_mat2d_rotate (HomMat2DScale, Angle, 0, 0, HomMat2DRotate)</l>
<l>*     hom_mat2d_translate (HomMat2DRotate, Row, Column, HomMat2DTranslate)</l>
<l>*     affine_trans_contour_xld (ModelContours, ContoursAffineTrans, HomMat2DTranslate)</l>
<c>   </c>
<l>*     gen_cross_contour_xld (Cross, Row, Column, 20, 0)</l>
<l>*     gen_arrow_contour_xld (Arrow, Row, Column, Row - cos(Angle - pi/2)*60 , Column - sin(Angle - pi/2)*60 , 5, 5)</l>
<l>*     dev_set_line_width(1)</l>
<l>*     dev_set_color ('green')</l>
<l>*     dev_display (ContoursAffineTrans)   </l>
<l>*     dev_display (Cross)</l>
<l>*     dev_set_color ('red')</l>
<l>*     dev_display (Arrow)</l>
<l>*     dev_set_color ('yellow')</l>
<c>    </c>
<c>    *3.使用测量工具测量精密中心和角度。</c>
<c>    *计算模板匹配后物料的长和宽。</c>
<l>    L1_new := sqrt(( ScaleR*Length1*cos(Angle) )*( ScaleR*Length1*cos(Angle) ) \
                   + ( ScaleC*Length1*sin(Angle) )*( ScaleC*Length1*sin(Angle) ) )</l>
<l>    L2_new := sqrt(( ScaleC*Length2*cos(Angle) )*( ScaleC*Length2*cos(Angle) ) \
                   + ( ScaleR*Length2*sin(Angle) )*( ScaleR*Length2*sin(Angle) ) )</l>
<c>    </c>
<l>*     smallest_rectangle2 (RegionClosing1, Row1, Column1, Phi, Length1, Length2)</l>
<l>*     gen_rectangle2 (Rectangle, Row1, Column1, Phi, Length1, Length2)</l>
<l>*     dilation_circle (Rectangle, RegionDilation, 5)</l>
<l>*     reduce_domain (Image, RegionDilation, ImageReduced3)</l>
<c>    </c>
<l>    add_metrology_object_rectangle2_measure (MetrologyHandle, Row, Column, Angle, L2_new, L1_new, \
                                         20, 5, 2, 20, ['measure_transition'], ['positive'], Index2)</l>
<l>    apply_metrology_model (Image, MetrologyHandle)</l>
<l>    get_metrology_object_result (MetrologyHandle, Index2, 'all', 'result_type', \
                                 'all_param', Parameter)</l>
<l>    get_metrology_object_result_contour (Contour, MetrologyHandle, Index2, 'all', 1.5)</l>
<l>    dev_display (Contour)</l>
<l>    dev_set_color ('green')</l>
<l>    get_metrology_object_measures (Contours, MetrologyHandle, Index2, 'all', Row2, Column2)</l>
<l>    dev_display (Contours)</l>
<l>    dev_set_color ('yellow')</l>
<l>    gen_cross_contour_xld (Cross, Row2, Column2, 6, 0.785398)</l>
<l>    dev_display (Cross)</l>
<l>    *stop()</l>
<l>    gen_cross_contour_xld (Cross, Parameter[0], Parameter[1], 20, 0)</l>
<l>    gen_arrow_contour_xld (Arrow, Parameter[0], Parameter[1], Parameter[0] - cos(Parameter[2] - pi/2)*60 , Parameter[1] - sin(Parameter[2] - pi/2)*60 , 5, 5)</l>
<l>    dev_set_line_width(1)</l>
<l>    dev_set_color ('green')</l>
<l>*     dev_display (ContoursAffineTrans)   </l>
<l>    dev_display (Cross)</l>
<l>    dev_set_color ('red')</l>
<l>    dev_display (Arrow)</l>
<l>    dev_set_color ('yellow')</l>
<c>    </c>
<l>    count_seconds (Second2)</l>
<l>    Time1 := round(1000*(Second2 - Second1))</l>
<c>    </c>
<l>    set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>    disp_message (WindowHandle, '基于异向缩放轮廓模板匹配(绿色十字和红色箭头):', 'window', 10, 20, 'red', 'true')    </l>
<l>    disp_message (WindowHandle, 'X:'+Parameter[0], 'window', 40, 20, 'black', 'true')</l>
<l>    disp_message (WindowHandle, 'Y:'+Parameter[1], 'window', 60, 20, 'black', 'true')</l>
<l>    ANGLE := deg(Parameter[2])</l>
<l>    disp_message (WindowHandle, 'ANGLE:' + ANGLE$'3.2f' + '°', 'window', 80, 20, 'black', 'true')</l>
<l>    disp_message (WindowHandle, '基于异向缩放轮廓模板Time:' + Time1$'.2f' + 'ms', 'window', 45, 500, 'green', 'false')</l>
<c>    </c>
<l>    dump_window_image (Image1, WindowHandle)</l>
<l>    dev_display (Image1)</l>
<l>    stop()</l>
<l>endfor</l>
<c></c>
<l>clear_metrology_model (MetrologyHandle)</l>
<l>clear_shape_model (ModelID)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
